{"version":3,"file":"970-48370d7511d93a9ca80b.js","mappings":"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","sources":["webpack:///../../../../node_modules/lodash/isNumber.js","webpack:///../../../../node_modules/lodash/isString.js","webpack:///../../../../node_modules/rsuite/esm/MaskedInput/adjustCaretPosition.js","webpack:///../../../../node_modules/rsuite/esm/MaskedInput/utilities.js","webpack:///../../../../node_modules/rsuite/esm/MaskedInput/createTextMaskInputElement.js","webpack:///../../../../node_modules/rsuite/esm/MaskedInput/conformToMask.js","webpack:///../../../../node_modules/rsuite/esm/MaskedInput/TextMask.js"],"sourcesContent":["var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar numberTag = '[object Number]';\n\n/**\n * Checks if `value` is classified as a `Number` primitive or object.\n *\n * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n * classified as numbers, use the `_.isFinite` method.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n * @example\n *\n * _.isNumber(3);\n * // => true\n *\n * _.isNumber(Number.MIN_VALUE);\n * // => true\n *\n * _.isNumber(Infinity);\n * // => true\n *\n * _.isNumber('3');\n * // => false\n */\nfunction isNumber(value) {\n  return typeof value == 'number' ||\n    (isObjectLike(value) && baseGetTag(value) == numberTag);\n}\n\nmodule.exports = isNumber;\n","var baseGetTag = require('./_baseGetTag'),\n    isArray = require('./isArray'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n}\n\nmodule.exports = isString;\n","var defaultArray = [];\nvar emptyString = '';\nexport default function adjustCaretPosition(_ref) {\n  var _ref$previousConforme = _ref.previousConformedValue,\n      previousConformedValue = _ref$previousConforme === void 0 ? emptyString : _ref$previousConforme,\n      _ref$previousPlacehol = _ref.previousPlaceholder,\n      previousPlaceholder = _ref$previousPlacehol === void 0 ? emptyString : _ref$previousPlacehol,\n      _ref$currentCaretPosi = _ref.currentCaretPosition,\n      currentCaretPosition = _ref$currentCaretPosi === void 0 ? 0 : _ref$currentCaretPosi,\n      conformedValue = _ref.conformedValue,\n      rawValue = _ref.rawValue,\n      placeholderChar = _ref.placeholderChar,\n      placeholder = _ref.placeholder,\n      _ref$indexesOfPipedCh = _ref.indexesOfPipedChars,\n      indexesOfPipedChars = _ref$indexesOfPipedCh === void 0 ? defaultArray : _ref$indexesOfPipedCh,\n      _ref$caretTrapIndexes = _ref.caretTrapIndexes,\n      caretTrapIndexes = _ref$caretTrapIndexes === void 0 ? defaultArray : _ref$caretTrapIndexes;\n\n  if (currentCaretPosition === 0 || !rawValue.length) {\n    return 0;\n  } // Store lengths for faster performance?\n\n\n  var rawValueLength = rawValue.length;\n  var previousConformedValueLength = previousConformedValue.length;\n  var placeholderLength = placeholder.length;\n  var conformedValueLength = conformedValue.length; // This tells us how long the edit is. If user modified input from `(2__)` to `(243__)`,\n  // we know the user in this instance pasted two characters\n\n  var editLength = rawValueLength - previousConformedValueLength; // If the edit length is positive, that means the user is adding characters, not deleting.\n\n  var isAddition = editLength > 0; // This is the first raw value the user entered that needs to be conformed to mask\n\n  var isFirstRawValue = previousConformedValueLength === 0; // A partial multi-character edit happens when the user makes a partial selection in their\n  // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by\n  // selecting the first 3 digits and pressing backspace.\n  //\n  // Such cases can also happen when the user presses the backspace while holding down the ALT\n  // key.\n\n  var isPartialMultiCharEdit = editLength > 1 && !isFirstRawValue; // This algorithm doesn't support all cases of multi-character edits, so we just return\n  // the current caret position.\n  //\n  // This works fine for most cases.\n\n  if (isPartialMultiCharEdit) {\n    return currentCaretPosition;\n  } // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter\n  // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the\n  // same as the original `previousConformedValue`. We handle this case differently for caret\n  // positioning.\n\n\n  var possiblyHasRejectedChar = isAddition && (previousConformedValue === conformedValue || conformedValue === placeholder);\n  var startingSearchIndex = 0;\n  var trackRightCharacter;\n  var targetChar;\n\n  if (possiblyHasRejectedChar) {\n    startingSearchIndex = currentCaretPosition - editLength;\n  } else {\n    // At this point in the algorithm, we want to know where the caret is right before the raw input\n    // has been conformed, and then see if we can find that same spot in the conformed input.\n    //\n    // We do that by seeing what character lies immediately before the caret, and then look for that\n    // same character in the conformed input and place the caret there.\n    // First, we need to normalize the inputs so that letter capitalization between raw input and\n    // conformed input wouldn't matter.\n    var normalizedConformedValue = conformedValue.toLowerCase();\n    var normalizedRawValue = rawValue.toLowerCase(); // Then we take all characters that come before where the caret currently is.\n\n    var leftHalfChars = normalizedRawValue.substr(0, currentCaretPosition).split(emptyString); // Now we find all the characters in the left half that exist in the conformed input\n    // This step ensures that we don't look for a character that was filtered out or rejected by `conformToMask`.\n\n    var intersection = leftHalfChars.filter(function (char) {\n      return normalizedConformedValue.indexOf(char) !== -1;\n    }); // The last character in the intersection is the character we want to look for in the conformed\n    // value and the one we want to adjust the caret close to\n\n    targetChar = intersection[intersection.length - 1]; // Calculate the number of mask characters in the previous placeholder\n    // from the start of the string up to the place where the caret is\n\n    var previousLeftMaskChars = previousPlaceholder.substr(0, intersection.length).split(emptyString).filter(function (char) {\n      return char !== placeholderChar;\n    }).length; // Calculate the number of mask characters in the current placeholder\n    // from the start of the string up to the place where the caret is\n\n    var leftMaskChars = placeholder.substr(0, intersection.length).split(emptyString).filter(function (char) {\n      return char !== placeholderChar;\n    }).length; // Has the number of mask characters up to the caret changed?\n\n    var masklengthChanged = leftMaskChars !== previousLeftMaskChars; // Detect if `targetChar` is a mask character and has moved to the left\n\n    var targetIsMaskMovingLeft = previousPlaceholder[intersection.length - 1] !== undefined && placeholder[intersection.length - 2] !== undefined && previousPlaceholder[intersection.length - 1] !== placeholderChar && previousPlaceholder[intersection.length - 1] !== placeholder[intersection.length - 1] && previousPlaceholder[intersection.length - 1] === placeholder[intersection.length - 2]; // If deleting and the `targetChar` `is a mask character and `masklengthChanged` is true\n    // or the mask is moving to the left, we can't use the selected `targetChar` any longer\n    // if we are not at the end of the string.\n    // In this case, change tracking strategy and track the character to the right of the caret.\n\n    if (!isAddition && (masklengthChanged || targetIsMaskMovingLeft) && previousLeftMaskChars > 0 && placeholder.indexOf(targetChar) > -1 && rawValue[currentCaretPosition] !== undefined) {\n      trackRightCharacter = true;\n      targetChar = rawValue[currentCaretPosition];\n    } // It is possible that `targetChar` will appear multiple times in the conformed value.\n    // We need to know not to select a character that looks like our target character from the placeholder or\n    // the piped characters, so we inspect the piped characters and the placeholder to see if they contain\n    // characters that match our target character.\n    // If the `conformedValue` got piped, we need to know which characters were piped in so that when we look for\n    // our `targetChar`, we don't select a piped char by mistake\n\n\n    var pipedChars = indexesOfPipedChars.map(function (index) {\n      return normalizedConformedValue[index];\n    }); // We need to know how many times the `targetChar` occurs in the piped characters.\n\n    var countTargetCharInPipedChars = pipedChars.filter(function (char) {\n      return char === targetChar;\n    }).length; // We need to know how many times it occurs in the intersection\n\n    var countTargetCharInIntersection = intersection.filter(function (char) {\n      return char === targetChar;\n    }).length; // We need to know if the placeholder contains characters that look like\n    // our `targetChar`, so we don't select one of those by mistake.\n\n    var countTargetCharInPlaceholder = placeholder.substr(0, placeholder.indexOf(placeholderChar)).split(emptyString).filter(function (char, index) {\n      return (// Check if `char` is the same as our `targetChar`, so we account for it\n        char === targetChar && // but also make sure that both the `rawValue` and placeholder don't have the same character at the same\n        // index because if they are equal, that means we are already counting those characters in\n        // `countTargetCharInIntersection`\n        rawValue[index] !== char\n      );\n    }).length; // The number of times we need to see occurrences of the `targetChar` before we know it is the one we're looking\n    // for is:\n\n    var requiredNumberOfMatches = countTargetCharInPlaceholder + countTargetCharInIntersection + countTargetCharInPipedChars + ( // The character to the right of the caret isn't included in `intersection`\n    // so add one if we are tracking the character to the right\n    trackRightCharacter ? 1 : 0); // Now we start looking for the location of the `targetChar`.\n    // We keep looping forward and store the index in every iteration. Once we have encountered\n    // enough occurrences of the target character, we break out of the loop\n    // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.\n\n    var numberOfEncounteredMatches = 0;\n\n    for (var i = 0; i < conformedValueLength; i++) {\n      var conformedValueChar = normalizedConformedValue[i];\n      startingSearchIndex = i + 1;\n\n      if (conformedValueChar === targetChar) {\n        numberOfEncounteredMatches++;\n      }\n\n      if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\n        break;\n      }\n    }\n  } // At this point, if we simply return `startingSearchIndex` as the adjusted caret position,\n  // most cases would be handled. However, we want to fast forward or rewind the caret to the\n  // closest placeholder character if it happens to be in a non-editable spot. That's what the next\n  // logic is for.\n  // In case of addition, we fast forward.\n\n\n  if (isAddition) {\n    // We want to remember the last placeholder character encountered so that if the mask\n    // contains more characters after the last placeholder character, we don't forward the caret\n    // that far to the right. Instead, we stop it at the last encountered placeholder character.\n    var lastPlaceholderChar = startingSearchIndex;\n\n    for (var _i = startingSearchIndex; _i <= placeholderLength; _i++) {\n      if (placeholder[_i] === placeholderChar) {\n        lastPlaceholderChar = _i;\n      }\n\n      if ( // If we're adding, we can position the caret at the next placeholder character.\n      placeholder[_i] === placeholderChar || // If a caret trap was set by a mask function, we need to stop at the trap.\n      caretTrapIndexes.indexOf(_i) !== -1 || // This is the end of the placeholder. We cannot move any further. Let's put the caret there.\n      _i === placeholderLength) {\n        return lastPlaceholderChar;\n      }\n    }\n  } else {\n    // In case of deletion, we rewind.\n    if (trackRightCharacter) {\n      // Searching for the character that was to the right of the caret\n      // We start at `startingSearchIndex` - 1 because it includes one character extra to the right\n      for (var _i2 = startingSearchIndex - 1; _i2 >= 0; _i2--) {\n        // If tracking the character to the right of the cursor, we move to the left until\n        // we found the character and then place the caret right before it\n        if ( // `targetChar` should be in `conformedValue`, since it was in `rawValue`, just\n        // to the right of the caret\n        conformedValue[_i2] === targetChar || // If a caret trap was set by a mask function, we need to stop at the trap.\n        caretTrapIndexes.indexOf(_i2) !== -1 || // This is the beginning of the placeholder. We cannot move any further.\n        // Let's put the caret there.\n        _i2 === 0) {\n          return _i2;\n        }\n      }\n    } else {\n      // Searching for the first placeholder or caret trap to the left\n      for (var _i3 = startingSearchIndex; _i3 >= 0; _i3--) {\n        // If we're deleting, we stop the caret right before the placeholder character.\n        // For example, for mask `(111) 11`, current conformed input `(456) 86`. If user\n        // modifies input to `(456 86`. That is, they deleted the `)`, we place the caret\n        // right after the first `6`\n        if ( // If we're deleting, we can position the caret right before the placeholder character\n        placeholder[_i3 - 1] === placeholderChar || // If a caret trap was set by a mask function, we need to stop at the trap.\n        caretTrapIndexes.indexOf(_i3) !== -1 || // This is the beginning of the placeholder. We cannot move any further.\n        // Let's put the caret there.\n        _i3 === 0) {\n          return _i3;\n        }\n      }\n    }\n  }\n}","var emptyArray = [];\nvar strCaretTrap = '[]';\nexport var defaultPlaceholderChar = '_';\nexport function convertMaskToPlaceholder(mask, placeholderChar) {\n  if (mask === void 0) {\n    mask = emptyArray;\n  }\n\n  if (placeholderChar === void 0) {\n    placeholderChar = defaultPlaceholderChar;\n  }\n\n  if (!Array.isArray(mask)) {\n    throw new Error('Text-mask:convertMaskToPlaceholder; The mask property must be an array.');\n  }\n\n  if (mask.indexOf(placeholderChar) !== -1) {\n    throw new Error('Placeholder character must not be used as part of the mask. Please specify a character ' + 'that is not present in your mask as your placeholder character.\\n\\n' + (\"The placeholder character that was received is: \" + JSON.stringify(placeholderChar) + \"\\n\\n\") + (\"The mask that was received is: \" + JSON.stringify(mask)));\n  }\n\n  return mask.map(function (char) {\n    return char instanceof RegExp ? placeholderChar : char;\n  }).join('');\n}\nexport function processCaretTraps(mask) {\n  var indexes = [];\n  var indexOfCaretTrap;\n\n  while (indexOfCaretTrap = mask.indexOf(strCaretTrap), indexOfCaretTrap !== -1) {\n    indexes.push(indexOfCaretTrap);\n    mask.splice(indexOfCaretTrap, 1);\n  }\n\n  return {\n    maskWithoutCaretTraps: mask,\n    indexes: indexes\n  };\n}","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport isString from 'lodash/isString';\nimport isNumber from 'lodash/isNumber';\nimport adjustCaretPosition from './adjustCaretPosition';\nimport conformToMask from './conformToMask';\nimport { convertMaskToPlaceholder, processCaretTraps, defaultPlaceholderChar } from './utilities';\nvar emptyString = '';\nvar strNone = 'none';\nvar strObject = 'object';\nvar isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\nvar defer = typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame : setTimeout;\nexport default function createTextMaskInputElement(config) {\n  // Anything that we will need to keep between `update` calls, we will store in this `state` object.\n  var state = {\n    previousConformedValue: undefined,\n    previousPlaceholder: undefined\n  };\n  return {\n    state: state,\n    // `update` is called by framework components whenever they want to update the `value` of the input element.\n    // The caller can send a `rawValue` to be conformed and set on the input element. However, the default use-case\n    // is for this to be read from the `inputElement` directly.\n    update: function update(rawValue, _temp) {\n      var _pipeResults, _pipeResults2;\n\n      var _ref = _temp === void 0 ? config : _temp,\n          inputElement = _ref.inputElement,\n          providedMask = _ref.mask,\n          guide = _ref.guide,\n          pipe = _ref.pipe,\n          _ref$placeholderChar = _ref.placeholderChar,\n          placeholderChar = _ref$placeholderChar === void 0 ? defaultPlaceholderChar : _ref$placeholderChar,\n          _ref$keepCharPosition = _ref.keepCharPositions,\n          keepCharPositions = _ref$keepCharPosition === void 0 ? false : _ref$keepCharPosition,\n          _ref$showMask = _ref.showMask,\n          showMask = _ref$showMask === void 0 ? false : _ref$showMask;\n\n      // if `rawValue` is `undefined`, read from the `inputElement`\n      if (typeof rawValue === 'undefined') {\n        rawValue = inputElement.value;\n      } // If `rawValue` equals `state.previousConformedValue`, we don't need to change anything. So, we return.\n      // This check is here to handle controlled framework components that repeat the `update` call on every render.\n\n\n      if (rawValue === state.previousConformedValue) {\n        return;\n      } // Text Mask accepts masks that are a combination of a `mask` and a `pipe` that work together. If such a `mask` is\n      // passed, we destructure it below, so the rest of the code can work normally as if a separate `mask` and a `pipe`\n      // were passed.\n\n\n      if (typeof providedMask === strObject && providedMask.pipe !== undefined && providedMask.mask !== undefined) {\n        pipe = providedMask.pipe;\n        providedMask = providedMask.mask;\n      } // The `placeholder` is an essential piece of how Text Mask works. For a mask like `(111)`, the placeholder would\n      // be `(___)` if the `placeholderChar` is set to `_`.\n\n\n      var placeholder; // We don't know what the mask would be yet. If it is an array, we take it as is, but if it's a function, we will\n      // have to call that function to get the mask array.\n\n      var mask; // If the provided mask is an array, we can call `convertMaskToPlaceholder` here once and we'll always have the\n      // correct `placeholder`.\n\n      if (providedMask instanceof Array) {\n        placeholder = convertMaskToPlaceholder(providedMask, placeholderChar);\n      } // In framework components that support reactivity, it's possible to turn off masking by passing\n      // `false` for `mask` after initialization. See https://github.com/text-mask/text-mask/pull/359\n\n\n      if (providedMask === false) {\n        return;\n      } // We check the provided `rawValue` before moving further.\n      // If it's something we can't work with `getSafeRawValue` will throw.\n\n\n      var safeRawValue = getSafeRawValue(rawValue); // `selectionEnd` indicates to us where the caret position is after the user has typed into the input\n\n      var currentCaretPosition = inputElement.selectionEnd; // We need to know what the `previousConformedValue` and `previousPlaceholder` is from the previous `update` call\n\n      var previousConformedValue = state.previousConformedValue,\n          previousPlaceholder = state.previousPlaceholder;\n      var caretTrapIndexes; // If the `providedMask` is a function. We need to call it at every `update` to get the `mask` array.\n      // Then we also need to get the `placeholder`\n\n      if (typeof providedMask === 'function') {\n        mask = providedMask(safeRawValue, {\n          currentCaretPosition: currentCaretPosition,\n          previousConformedValue: previousConformedValue,\n          placeholderChar: placeholderChar\n        }); // disable masking if `mask` is `false`\n\n        if (mask === false) {\n          return;\n        } // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n        // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return\n        // the indexes of the caret traps.\n\n\n        var _processCaretTraps = processCaretTraps(mask),\n            maskWithoutCaretTraps = _processCaretTraps.maskWithoutCaretTraps,\n            indexes = _processCaretTraps.indexes;\n\n        mask = maskWithoutCaretTraps; // The processed mask is what we're interested in\n\n        caretTrapIndexes = indexes; // And we need to store these indexes because they're needed by `adjustCaretPosition`\n\n        placeholder = convertMaskToPlaceholder(mask, placeholderChar); // If the `providedMask` is not a function, we just use it as-is.\n      } else {\n        mask = providedMask;\n      } // The following object will be passed to `conformToMask` to determine how the `rawValue` will be conformed\n\n\n      var conformToMaskConfig = {\n        previousConformedValue: previousConformedValue,\n        guide: guide,\n        placeholderChar: placeholderChar,\n        pipe: pipe,\n        placeholder: placeholder,\n        currentCaretPosition: currentCaretPosition,\n        keepCharPositions: keepCharPositions\n      }; // `conformToMask` returns `conformedValue` as part of an object for future API flexibility\n\n      var _conformToMask = conformToMask(safeRawValue, mask, conformToMaskConfig),\n          conformedValue = _conformToMask.conformedValue; // The following few lines are to support the `pipe` feature.\n\n\n      var piped = typeof pipe === 'function';\n      var pipeResults = {}; // If `pipe` is a function, we call it.\n\n      if (piped) {\n        // `pipe` receives the `conformedValue` and the configurations with which `conformToMask` was called.\n        pipeResults = pipe(conformedValue, _extends({\n          rawValue: safeRawValue\n        }, conformToMaskConfig)); // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just return `false` to\n        // indicate rejection. Or return just a string when there are no piped characters.\n        // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest\n        // of the code can work with.\n\n        if (pipeResults === false) {\n          // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`, and set `rejected` to `true`.\n          pipeResults = {\n            value: previousConformedValue,\n            rejected: true\n          };\n        } else if (isString(pipeResults)) {\n          pipeResults = {\n            value: pipeResults\n          };\n        }\n      } // Before we proceed, we need to know which conformed value to use, the one returned by the pipe or the one\n      // returned by `conformToMask`.\n\n\n      var finalConformedValue = piped ? (_pipeResults = pipeResults) === null || _pipeResults === void 0 ? void 0 : _pipeResults.value : conformedValue; // After determining the conformed value, we will need to know where to set\n      // the caret position. `adjustCaretPosition` will tell us.\n\n      var adjustedCaretPosition = adjustCaretPosition({\n        previousConformedValue: previousConformedValue,\n        previousPlaceholder: previousPlaceholder,\n        conformedValue: finalConformedValue,\n        placeholder: placeholder,\n        rawValue: safeRawValue,\n        currentCaretPosition: currentCaretPosition,\n        placeholderChar: placeholderChar,\n        indexesOfPipedChars: (_pipeResults2 = pipeResults) === null || _pipeResults2 === void 0 ? void 0 : _pipeResults2.indexesOfPipedChars,\n        caretTrapIndexes: caretTrapIndexes\n      }); // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\n\n      var inputValueShouldBeEmpty = finalConformedValue === placeholder && adjustedCaretPosition === 0;\n      var emptyValue = showMask ? placeholder : emptyString;\n      var inputElementValue = inputValueShouldBeEmpty ? emptyValue : finalConformedValue;\n      state.previousConformedValue = inputElementValue; // store value for access for next time\n\n      state.previousPlaceholder = placeholder; // In some cases, this `update` method will be repeatedly called with a raw value that has already been conformed\n      // and set to `inputElement.value`. The below check guards against needlessly readjusting the input state.\n      // See https://github.com/text-mask/text-mask/issues/231\n\n      if (inputElement.value === inputElementValue) {\n        return;\n      }\n\n      inputElement.value = inputElementValue; // set the input value\n\n      safeSetSelection(inputElement, adjustedCaretPosition); // adjust caret position\n    }\n  };\n}\n\nfunction safeSetSelection(element, selectionPosition) {\n  if (document.activeElement === element) {\n    if (isAndroid) {\n      defer(function () {\n        return element.setSelectionRange(selectionPosition, selectionPosition, strNone);\n      }, 0);\n    } else {\n      element.setSelectionRange(selectionPosition, selectionPosition, strNone);\n    }\n  }\n}\n\nfunction getSafeRawValue(inputValue) {\n  if (isString(inputValue)) {\n    return inputValue;\n  } else if (isNumber(inputValue)) {\n    return String(inputValue);\n  } else if (inputValue === undefined || inputValue === null) {\n    return emptyString;\n  } else {\n    throw new Error(\"The 'value' provided to Text Mask needs to be a string or a number. The value received was:\\n\\n \" + JSON.stringify(inputValue));\n  }\n}","import { convertMaskToPlaceholder, processCaretTraps, defaultPlaceholderChar } from './utilities';\nexport function isArray(value) {\n  return Array.isArray && Array.isArray(value) || value instanceof Array;\n}\nexport default function conformToMask(rawValue, mask, config) {\n  if (rawValue === void 0) {\n    rawValue = '';\n  }\n\n  if (mask === void 0) {\n    mask = [];\n  }\n\n  if (config === void 0) {\n    config = {};\n  }\n\n  if (!isArray(mask)) {\n    // If someone passes a function as the mask property, we should call the\n    // function to get the mask array - Normally this is handled by the\n    // `createTextMaskInputElement:update` function - this allows mask functions\n    // to be used directly with `conformToMask`\n    if (typeof mask === 'function') {\n      // call the mask function to get the mask array\n      mask = mask(rawValue, config); // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n      // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask\n\n      mask = processCaretTraps(mask).maskWithoutCaretTraps;\n    } else {\n      throw new Error('Text-mask:conformToMask; The mask property must be an array.');\n    }\n  } // These configurations tell us how to conform the mask\n\n\n  var _config = config,\n      _config$guide = _config.guide,\n      guide = _config$guide === void 0 ? true : _config$guide,\n      _config$previousConfo = _config.previousConformedValue,\n      previousConformedValue = _config$previousConfo === void 0 ? '' : _config$previousConfo,\n      _config$placeholderCh = _config.placeholderChar,\n      placeholderChar = _config$placeholderCh === void 0 ? defaultPlaceholderChar : _config$placeholderCh,\n      _config$placeholder = _config.placeholder,\n      placeholder = _config$placeholder === void 0 ? convertMaskToPlaceholder(mask, placeholderChar) : _config$placeholder,\n      _config$currentCaretP = _config.currentCaretPosition,\n      currentCaretPosition = _config$currentCaretP === void 0 ? 0 : _config$currentCaretP,\n      keepCharPositions = _config.keepCharPositions; // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n\n  var suppressGuide = guide === false && previousConformedValue !== undefined; // Calculate lengths once for performance\n\n  var rawValueLength = rawValue.length;\n  var previousConformedValueLength = previousConformedValue.length;\n  var placeholderLength = placeholder.length;\n  var maskLength = mask.length; // This tells us the number of edited characters and the direction in which they were edited (+/-)\n\n  var editDistance = rawValueLength - previousConformedValueLength; // In *no guide* mode, we need to know if the user is trying to add a character or not\n\n  var isAddition = editDistance > 0; // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n\n  var indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0); // We're also gonna need the index of last change, which we can derive as follows...\n\n  var indexOfLastChange = indexOfFirstChange + Math.abs(editDistance); // If `conformToMask` is configured to keep character positions, that is, for mask 111, previous value\n  // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of\n  // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be\n  // __3, not _3_ (default behavior)\n  //\n  // The next block of logic handles keeping character positions for the case of deletion. (Keeping\n  // character positions for the case of addition is further down since it is handled differently.)\n  // To do this, we want to compensate for all characters that were deleted\n\n  if (keepCharPositions === true && !isAddition) {\n    // We will be storing the new placeholder characters in this variable.\n    var compensatingPlaceholderChars = ''; // For every character that was deleted from a placeholder position, we add a placeholder char\n\n    for (var i = indexOfFirstChange; i < indexOfLastChange; i++) {\n      if (placeholder[i] === placeholderChar) {\n        compensatingPlaceholderChars += placeholderChar;\n      }\n    } // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters\n    // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters\n    // in their positions.\n\n\n    rawValue = rawValue.slice(0, indexOfFirstChange) + compensatingPlaceholderChars + rawValue.slice(indexOfFirstChange, rawValueLength);\n  } // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have\n  // existed in the previous conformed value. Identifying new and old characters is needed for `conformToMask`\n  // to work if it is configured to keep character positions.\n\n\n  var rawValueArr = rawValue.split('').map(function (char, i) {\n    return {\n      char: char,\n      isNew: i >= indexOfFirstChange && i < indexOfLastChange\n    };\n  }); // The loop below removes masking characters from user input. For example, for mask\n  // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\n  // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm\n  // then would lay `234` on top of the available placeholder positions in the mask.\n\n  for (var _i = rawValueLength - 1; _i >= 0; _i--) {\n    var char = rawValueArr[_i].char;\n\n    if (char !== placeholderChar) {\n      var shouldOffset = _i >= indexOfFirstChange && previousConformedValueLength === maskLength;\n\n      if (char === placeholder[shouldOffset ? _i - editDistance : _i]) {\n        rawValueArr.splice(_i, 1);\n      }\n    }\n  } // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n\n\n  var conformedValue = '';\n  var someCharsRejected = false; // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n\n  placeholderLoop: for (var _i2 = 0; _i2 < placeholderLength; _i2++) {\n    var charInPlaceholder = placeholder[_i2]; // We see one. Let's find out what we can put in it.\n\n    if (charInPlaceholder === placeholderChar) {\n      // But before that, do we actually have any user characters that need a place?\n      if (rawValueArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (rawValueArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          var _ref = rawValueArr.shift(),\n              rawValueChar = _ref.char,\n              isNew = _ref.isNew; // If the character we got from the user input is a placeholder character (which happens\n          // regularly because user input could be something like (540) 90_-____, which includes\n          // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\n          // then we map this placeholder character to the current spot in the placeholder\n\n\n          if (rawValueChar === placeholderChar && suppressGuide !== true) {\n            conformedValue += placeholderChar; // And we go to find the next placeholder character that needs filling\n\n            continue placeholderLoop; // Else if, the character we got from the user input is not a placeholder, let's see\n            // if the current position in the mask can accept it.\n          } else if (mask[_i2].test(rawValueChar)) {\n            // we map the character differently based on whether we are keeping character positions or not.\n            // If any of the conditions below are met, we simply map the raw value character to the\n            // placeholder position.\n            if (keepCharPositions !== true || isNew === false || previousConformedValue === '' || guide === false || !isAddition) {\n              conformedValue += rawValueChar;\n            } else {\n              // We enter this block of code if we are trying to keep character positions and none of the conditions\n              // above is met. In this case, we need to see if there's an available spot for the raw value character\n              // to be mapped to. If we couldn't find a spot, we will discard the character.\n              //\n              // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the\n              // `9`, to the first available placeholder position, but then, there are no more spots available for the\n              // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.\n              var rawValueArrLength = rawValueArr.length;\n              var indexOfNextAvailablePlaceholderChar = null; // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,\n              // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.\n              // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable\n              // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.\n\n              for (var _i3 = 0; _i3 < rawValueArrLength; _i3++) {\n                var charData = rawValueArr[_i3];\n\n                if (charData.char !== placeholderChar && charData.isNew === false) {\n                  break;\n                }\n\n                if (charData.char === placeholderChar) {\n                  indexOfNextAvailablePlaceholderChar = _i3;\n                  break;\n                }\n              } // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.\n              // We can map it. And to keep the character positions, we remove the placeholder character\n              // from the remaining characters\n\n\n              if (indexOfNextAvailablePlaceholderChar !== null) {\n                conformedValue += rawValueChar;\n                rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1); // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to\n                // discard it.\n              } else {\n                _i2--;\n              }\n            } // Since we've mapped this placeholder position. We move on to the next one.\n\n\n            continue placeholderLoop;\n          } else {\n            someCharsRejected = true;\n          }\n        }\n      } // We reach this point when we've mapped all the user input characters to placeholder\n      // positions in the mask. In *guide* mode, we append the left over characters in the\n      // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\n      //\n      // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\n\n\n      if (suppressGuide === false) {\n        conformedValue += placeholder.substr(_i2, placeholderLength);\n      } // And we break\n\n\n      break; // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it\n      // with user input. So we just map it to the final output\n    } else {\n      conformedValue += charInPlaceholder;\n    }\n  } // The following logic is needed to deal with the case of deletion in *no guide* mode.\n  //\n  // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\n  // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\n  // That's why the logic below finds the last filled placeholder character, and removes everything\n  // from that point on.\n\n\n  if (suppressGuide && isAddition === false) {\n    var indexOfLastFilledPlaceholderChar = null; // Find the last filled placeholder position and substring from there\n\n    for (var _i4 = 0; _i4 < conformedValue.length; _i4++) {\n      if (placeholder[_i4] === placeholderChar) {\n        indexOfLastFilledPlaceholderChar = _i4;\n      }\n    }\n\n    if (indexOfLastFilledPlaceholderChar !== null) {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);\n    } else {\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedValue = '';\n    }\n  }\n\n  return {\n    conformedValue: conformedValue,\n    meta: {\n      someCharsRejected: someCharsRejected\n    }\n  };\n}","import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport React, { useCallback, useEffect, useRef } from 'react';\nimport omit from 'lodash/omit';\nimport PropTypes from 'prop-types';\nimport createTextMaskInputElement from './createTextMaskInputElement';\nimport { mergeRefs } from '../utils';\n/**\n * https://github.com/text-mask/text-mask/blob/master/componentDocumentation.md#guide\n */\n\nvar defaultRender = function defaultRender(ref, props) {\n  return /*#__PURE__*/React.createElement(\"input\", _extends({\n    ref: ref\n  }, props));\n};\n\nvar TextMask = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  var mask = props.mask,\n      _props$guide = props.guide,\n      guide = _props$guide === void 0 ? true : _props$guide,\n      placeholderChar = props.placeholderChar,\n      value = props.value,\n      showMask = props.showMask,\n      pipe = props.pipe,\n      _props$render = props.render,\n      render = _props$render === void 0 ? defaultRender : _props$render,\n      onChange = props.onChange,\n      rest = _objectWithoutPropertiesLoose(props, [\"mask\", \"guide\", \"placeholderChar\", \"value\", \"showMask\", \"pipe\", \"render\", \"onChange\"]);\n\n  var inputRef = useRef(null);\n  var textMaskInputElement = useRef();\n  var initTextMask = useCallback(function () {\n    var _textMaskInputElement;\n\n    textMaskInputElement.current = createTextMaskInputElement(_extends({\n      inputElement: inputRef.current\n    }, props));\n    (_textMaskInputElement = textMaskInputElement.current) === null || _textMaskInputElement === void 0 ? void 0 : _textMaskInputElement.update(value);\n  }, [props, value]);\n  var handleChange = useCallback(function (event) {\n    var _textMaskInputElement2;\n\n    (_textMaskInputElement2 = textMaskInputElement.current) === null || _textMaskInputElement2 === void 0 ? void 0 : _textMaskInputElement2.update();\n    onChange === null || onChange === void 0 ? void 0 : onChange(event);\n  }, [onChange]);\n  useEffect(function () {\n    initTextMask();\n  }, [guide, placeholderChar, showMask, pipe, mask, value, initTextMask]);\n  return render(mergeRefs(inputRef, ref), _extends({\n    onChange: handleChange,\n    defaultValue: value\n  }, omit(rest, ['keepCharPositions'])));\n});\nTextMask.displayName = 'TextMask';\nTextMask.propTypes = {\n  render: PropTypes.func,\n  onChange: PropTypes.func,\n  mask: PropTypes.oneOfType([PropTypes.array, PropTypes.func, PropTypes.bool]).isRequired,\n  guide: PropTypes.bool,\n  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  pipe: PropTypes.func,\n  placeholderChar: PropTypes.string,\n  keepCharPositions: PropTypes.bool,\n  showMask: PropTypes.bool\n};\nexport default TextMask;"],"names":["baseGetTag","isObjectLike","module","exports","value","isArray","defaultArray","emptyString","emptyArray","strCaretTrap","defaultPlaceholderChar","convertMaskToPlaceholder","mask","placeholderChar","Array","Error","indexOf","JSON","stringify","map","char","RegExp","join","processCaretTraps","indexOfCaretTrap","indexes","push","splice","maskWithoutCaretTraps","strNone","strObject","isAndroid","navigator","test","userAgent","defer","requestAnimationFrame","setTimeout","createTextMaskInputElement","config","state","previousConformedValue","undefined","previousPlaceholder","update","rawValue","_temp","_pipeResults","_pipeResults2","placeholder","_ref","inputElement","providedMask","guide","pipe","_ref$placeholderChar","_ref$keepCharPosition","keepCharPositions","_ref$showMask","showMask","caretTrapIndexes","safeRawValue","inputValue","String","getSafeRawValue","currentCaretPosition","selectionEnd","_processCaretTraps","conformToMaskConfig","conformedValue","_config","_config$guide","_config$previousConfo","_config$placeholderCh","_config$placeholder","_config$currentCaretP","suppressGuide","rawValueLength","length","previousConformedValueLength","placeholderLength","maskLength","editDistance","isAddition","indexOfFirstChange","indexOfLastChange","Math","abs","compensatingPlaceholderChars","i","slice","rawValueArr","split","isNew","_i","someCharsRejected","placeholderLoop","_i2","charInPlaceholder","shift","rawValueChar","rawValueArrLength","indexOfNextAvailablePlaceholderChar","_i3","charData","substr","indexOfLastFilledPlaceholderChar","_i4","meta","conformToMask","piped","pipeResults","rejected","element","selectionPosition","finalConformedValue","adjustedCaretPosition","_ref$previousConforme","_ref$previousPlacehol","_ref$currentCaretPosi","_ref$indexesOfPipedCh","indexesOfPipedChars","_ref$caretTrapIndexes","conformedValueLength","editLength","trackRightCharacter","targetChar","startingSearchIndex","normalizedConformedValue","toLowerCase","intersection","filter","previousLeftMaskChars","masklengthChanged","targetIsMaskMovingLeft","countTargetCharInPipedChars","index","countTargetCharInIntersection","requiredNumberOfMatches","numberOfEncounteredMatches","lastPlaceholderChar","adjustCaretPosition","inputElementValue","document","activeElement","setSelectionRange","defaultRender","ref","props","TextMask","_props$guide","_props$render","render","onChange","rest","inputRef","useRef","textMaskInputElement","initTextMask","useCallback","_textMaskInputElement","current","handleChange","event","_textMaskInputElement2","useEffect","mergeRefs","defaultValue","displayName","propTypes","isRequired"],"sourceRoot":""}